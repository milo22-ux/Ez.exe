--[[made by _milo22 on dsicord well know for making cheats and cheating on trident survival (2023) or trident survival v5 if you want to skid this cheat then pls give me credit if not then i will not be happy bit that will be fine with me i would do nothing about it anyways but i would be happy if u atleast gave me credit but if not that is complty fine btw i am 15 and taken so don't dm me to date you peace out]]--

-- Locals to call the ui
local DrRayLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/AZYsGithub/DrRay-UI-Library/main/DrRay.lua"))()
--
local window = DrRayLibrary:Load("Ez bans.exe", "Default")
-- Combat
local tab = DrRayLibrary.newTab("Combat", "ImageIdHere")
tab.newButton("silent aim", "", function()
local modules = { ["Camera"] = {}, ["Player"] = {}, ["Character"] = {}, ["Inventory"] = {}, ["RangedWeapon"] = {}, ["BowSpecial"] = {}, ["FPS"] = {}, ["NetWork"] = {}, ["ClimbingPick"] = {}, ["BuildingTool"] = {}, ["Consumable"] = {}, ["Melee"] = {}, ["MiningDrill"] = {}, ["PlaceEntity"] = {}, ["PortableAnvil"] = {}, ["PortableWorkbench"] = {}, ["InputManager"] = {}, ["Particle"] = {}, ["Settings"] = {}, ["Sound"] = {}, ["UI"] = {}, }
for _, v in pairs(getgc(true)) do if typeof(v) == "function" and islclosure(v) then local info = debug.getinfo(v) local name = string.match(info.short_src, "%.([%w_]+)$") if name and modules[name] and info.name ~= nil then modules[name][info.name] = info.func end end end
local workspace,camera = cloneref(game:GetService("Workspace")), workspace.CurrentCamera
local UIS, RS, ReplicatedStorage = cloneref(game:GetService("UserInputService")), cloneref(game:GetService("RunService")), cloneref(game:GetService("ReplicatedStorage"))
local Fov, Sline = Drawing.new("Circle"), Drawing.new("Line")
local screenSize = camera.ViewportSize
local screenCenter = Vector2.new(screenSize.X / 2, screenSize.Y / 2)
Fov.Position = screenCenter Fov.Radius = 150 Fov.Color = Color3.fromRGB(255, 0, 255) Fov.Visible = true Sline.Color = Color3.fromRGB(255, 255, 255) Sline.Thickness = 1 Sline.Visible = true Sline.ZIndex = 1
local getclosest = function() local closestModel, closestData = nil, nil local closestMagnitude = math.huge local camera = workspace.CurrentCamera for _, v in pairs(debug.getupvalue(modules.Player.GetPlayerModel, 1) or {}) do if v.model:FindFirstChild("Head") and not v.sleeping then local pos, onScreen = camera:WorldToViewportPoint(v.model:GetPivot().Position) if onScreen then local magnitude = (Vector2.new(pos.X, pos.Y) - screenCenter).Magnitude local playerDistance = (workspace.Ignore.LocalCharacter.Middle:GetPivot().Position - v.model:GetPivot().Position).Magnitude if magnitude < Fov.Radius and playerDistance <= 9999 and magnitude < closestMagnitude then closestMagnitude = magnitude closestModel = v.model closestData = v end end end end return closestModel, closestData end
game:GetService("RunService").RenderStepped:Connect(function() getgenv().SilentTarget = getclosest() if getgenv().SilentTarget and getgenv().SilentTarget:FindFirstChild("Head") then local head_pos = getgenv().SilentTarget.Head.Position local screenPos, onScreen = camera:WorldToViewportPoint(head_pos) if onScreen then Sline.From = screenCenter Sline.To = Vector2.new(screenPos.X, screenPos.Y) Sline.Visible = true else Sline.Visible = false end else Sline.Visible = false end end)
local RunService, UserInputService, hue, speed = game:GetService("RunService"), game:GetService("UserInputService"), 0, 0.7 RunService.RenderStepped:Connect(function(dt) hue = (hue + (dt * speed * 100)) % 360 Fov.Color = Color3.fromHSV(hue / 360, 1, 1) end)  
local ProjectileDrop = function() local mod = modules.FPS.GetEquippedItem() if not mod or not mod.id then return 0, 0 end local itemConfig = require(game:GetService("ReplicatedStorage").ItemConfigs[mod.id]) return mod.id, itemConfig.ProjectileSpeed, itemConfig.ProjectileDrop end
local predict = function(p, e, s, d) local dt = (e - p).Magnitude local x = (math.pi * 2 - math.pi / 4) / 8 local t = dt / s local py = e.Y + (x * d * t) return Vector3.new(e.X, py, e.Z) end
local SilentAim = true
local oldfromOrientation; oldfromOrientation = hookfunction(CFrame.fromOrientation, newcclosure(function(p, y, r)
    if SilentAim and getgenv().SilentTarget and debug.info(3, "n") == "fire" then
        local id, speed, drop = ProjectileDrop()
        local targetHead = getgenv().SilentTarget.Head
        if targetHead then
            local origin = modules.Camera.GetCFrame()
            local Camera = game.workspace.CurrentCamera
            local cameraPosition = Camera.CFrame.Position
            local predictedPos = predict(origin.Position, targetHead.Position, speed, drop)
            if predictedPos then
                return Camera.CFrame:Inverse() * CFrame.lookAt(cameraPosition, predictedPos)
            end
        end
    end
    return oldfromOrientation(p, y, r)
end))
end)
--
tab.newToggle("Toggle hbe", "Toggle hbe (hitbox expander)", true, function(toggleState)
    Hitbox = toggleState 
end) 
tab.newSlider("hitbox size", "hitbox expander slider", 7, false, function(num)
    headsize = num
end)
--
local function modifyPlayerHeads()
    for i, v in next, game.Workspace:GetChildren() do
        if v.Name == "Model" and v:FindFirstChild("Head") then
            local head = v.Head
            if head then
                local success, _ = pcall(function()
                    head.Size = Vector3.new(headsize, headsize, headsize)
                    head.Transparency = 0.5
                end)
                if not success then
                    warn("Failed to modify head for player:", v.Name)
                end
            end
        end
    end
end
--
game:GetService("RunService").RenderStepped:Connect(function()
    if Hitbox then
        modifyPlayerHeads()
    end
end)
local deleteWallsEnabled = true

local Mouse = game.Players.LocalPlayer:GetMouse()

Mouse.Button1Down:Connect(function()
    if deleteWallsEnabled then
        if not Mouse.Target then return end

        local targetName = Mouse.Target.Name
        local allowedNames = {
            "Hitbox", "LeftWall", "RightWall",
            "LeftHinge", "Prim", "RightHinge"
        }

        for _, name in ipairs(allowedNames) do
            if targetName == name then
                Mouse.Target:Destroy()
                break
            end
        end
    end
end)

tab.newToggle("Delete Walls", "Enable/disable wall deletion on click", true, function(toggleState)
    deleteWallsEnabled = toggleState
end)
-- Visuals
local tab = DrRayLibrary.newTab("visuals", "ImageIdHere")
tab.newButton("esp", "boxes", function()
local VisionCore = {};
VisionCore.Modules = { ["Player"] = {} };
VisionCore.ESP_Boxes = {};
local Camera = workspace.CurrentCamera;
local RunService = game:GetService("RunService");
--
for _, func in pairs(getgc(true)) do
    if typeof(func) == "function" and islclosure(func) then
        local info = debug.getinfo(func)
        local name = string.match(info.short_src, "%.([%w_]+)$")
        if name and VisionCore.Modules[name] and info.name then
            VisionCore.Modules[name][info.name] = info.func
        end
    end
end
--
function VisionCore:Create(className, properties)
    local success, object = pcall(Drawing.new, className)
    if not success or not object then return nil end
    for prop, value in next, properties or {} do
        pcall(function() object[prop] = value end)
    end
    return object
end
--
function VisionCore:GetEntities()
    local result = {}
    for _, data in next, debug.getupvalue(VisionCore.Modules.Player.GetPlayerModel, 1) do
        if data and data.model and data.model:FindFirstChild("Head") and not data.sleeping then
            table.insert(result, data)
        end
    end
    return result
end
--
function VisionCore:SetupBox(entity)
    VisionCore.ESP_Boxes[entity.id] = VisionCore:Create("Square", {
        Thickness = 1,
        Color = Color3.fromRGB(255, 255, 255), -- White box
        Filled = false,
        Visible = false
    })
end
--
function VisionCore:UpdateAllBoxes()
    local entities = VisionCore:GetEntities()
    local trackedIDs = {}
    for _, ent in next, entities do
        trackedIDs[ent.id] = true
        if not VisionCore.ESP_Boxes[ent.id] then VisionCore:SetupBox(ent) end
        local box = VisionCore.ESP_Boxes[ent.id]
        local head = ent.model:FindFirstChild("Head") or ent.model:FindFirstChild("Torso")
        if head then
            VisionCore:UpdateBoxPosition(box, head)
        else
            VisionCore:HideBox(box)
        end
    end
    for id, box in next, VisionCore.ESP_Boxes do
        if not trackedIDs[id] then
            VisionCore:HideBox(box)
            VisionCore.ESP_Boxes[id] = nil
        end
    end
end
--
function VisionCore:UpdateBoxPosition(box, part)
    local screenPos, visible = Camera:WorldToViewportPoint(part.Position)
    local size = 35
    box.Size = Vector2.new(size, size)
    box.Position = Vector2.new(screenPos.X - size / 2, screenPos.Y - size / 2)
    box.Visible = visible
end
-- 
function VisionCore:HideBox(box)
    box.Visible = false
end
--
RunService.RenderStepped:Connect(function()
    VisionCore:UpdateAllBoxes()
end)
end)
tab.newButton("name and distance", "esp", function()
    local modules = { ["Player"] = {} }
    local ESP_Objects = {}
    local cam = workspace.CurrentCamera
    local uis = game:GetService("UserInputService")
    local rs = game:GetService("RunService")
    --
    for _, v in pairs(getgc(true)) do
        if typeof(v) == "function" and islclosure(v) then
            local info = debug.getinfo(v)
            local name = string.match(info.short_src, "%.([%w_]+)$")
            if name and modules[name] and info.name then
                modules[name][info.name] = info.func
            end
        end
    end
    --
    local function Create(className, properties)
        local success, object = pcall(Drawing.new, className)
        if not success or not object then return nil end
        for prop, value in next, properties or {} do
            pcall(function() object[prop] = value end)
        end
        return object
    end
    -- 
    local function GetPlayers()
        local players = {}
        for _, v in next, debug.getupvalue(modules.Player.GetPlayerModel, 1) do
            if v and v.model and v.model:FindFirstChild("Head") and not v.sleeping then
                table.insert(players, v)
            end
        end
        return players
    end
    -- 
    local function SetupESP(player)
        ESP_Objects[player.id] = Create("Text", {
            Text = ": Player :",
            Size = 17,
            Color = Color3.fromRGB(255, 255, 255),
            Outline = true,
            OutlineColor = Color3.fromRGB(0, 0, 0),
            Center = true,
            Visible = false
        })
    end
    --
    local function HideESP(esp)
        if esp then
            esp.Visible = false
        end
    end
    --
    local function UpdatePosition(esp, part)
        local pos, onScreen = cam:WorldToViewportPoint(part.Position)
        esp.Position = Vector2.new(pos.X, pos.Y)
        esp.Visible = onScreen
        if onScreen then
            UpdateText(esp, part)
        end
    end
    -- 
    function UpdateText(esp, part)
        esp.Text = "Player [ " .. math.floor((cam.CFrame.Position - part.Position).Magnitude) .. " ]"
    end
    -- 
    local function UpdateESP()
        local players = GetPlayers()
        local playerIds = {}
--
        for _, v in next, players do
            playerIds[v.id] = true
            if not ESP_Objects[v.id] then
                SetupESP(v)
            end
 --           
            local esp = ESP_Objects[v.id]
            local head = v.model:FindFirstChild("Head") or v.model:FindFirstChild("Torso")
            if head then
                UpdatePosition(esp, head)
            else
                HideESP(esp)
            end
        end
        --
        for id, esp in next, ESP_Objects do
            if not playerIds[id] then
                HideESP(esp)
                ESP_Objects[id] = nil
            end
        end
    end
    -- 
    rs.RenderStepped:Connect(function()
        UpdateESP()
    end)

end) 
workspace.ChildAdded:Connect(function(child)
    if child:FindFirstChild("Head") then
        createHighlight(child) 
    end
end)
    -- long neck
local longneck = {
    LongNeckEnabled = false,
    UpperLimitDefault = 3,
    LowerLimitDefault = 1.75,
    CurrentSliderValue = 1.75,
}
--
tab.newToggle("Long Neck Toggle", "Enable or disable long neck", true, function(toggleState)
    longneck.LongNeckEnabled = toggleState
    if toggleState then
        game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.UpperLimit = longneck.CurrentSliderValue
        game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.LowerLimit = longneck.CurrentSliderValue
    else
        game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.UpperLimit = longneck.UpperLimitDefault
        game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.LowerLimit = longneck.LowerLimitDefault
    end
end)
--
tab.newSlider("Neck Length", "Adjust neck length", 6, false, function(num)
    longneck.CurrentSliderValue = num
    if longneck.LongNeckEnabled then
        game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.UpperLimit = num
        game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.LowerLimit = num
    end
end)
    --no grass
local EnviromentEnabled = true
--
CreateToggle({
    Name = "Remove Grass",
    CurrentValue = false,
    Flag = "GrassToggle",
    Callback = function(toggleState)
        print(toggleState and "On" or "Off")
--
        if EnviromentEnabled then
            sethiddenproperty(game.Workspace.Terrain, "Decoration", not toggleState)
        end
    end
})
-- Xray
local antihitbox
antihitbox = hookmetamethod(game, "__newindex", function(self, key, value)
    if not checkcaller() and key == "Size" and self.Name == "Head" then
        return Vector3.new(1.67225, 0.835624, 0.835624)
    end
    return antihitbox(self, key, value)
end)
--
local antixray
antixray = hookmetamethod(game, "__newindex", function(self, key, value)
    if not checkcaller() and key == "Transparency" and self.Name == "Hitbox" then
        return 
    end
    return antixray(self, key, value)
end)
--
local CurrentSliderValue = 0.5
--
tab.newSlider("Xray Transparency", "Adjust hitbox transparency", 100, false, function(val)
    CurrentSliderValue = val / 100
end)
--
tab.newToggle("Xray Toggle", "Toggle visibility of player hitboxes", false, function(state)
    for _, v in pairs(game:GetService("Workspace"):GetChildren()) do
        if v:FindFirstChild("Hitbox") then
            v.Hitbox.Transparency = state and CurrentSliderValue or 0
        end
    end
end)
-- dw lil kid ik you skid
    local tab = DrRayLibrary.newTab("visuals 2", "ImageIdHere")
-- 
tab.newToggle("cardboard boxes", "Toggle cardboard boxes ESP", true, function(toggleState)
    --
    local espObjects = {}
    -- 
    local function createEsp(part)
        if part:IsA("UnionOperation") and part.BrickColor == BrickColor.new("Cashmere") and part.Material == Enum.Material.Plastic then
            local PartCrateEsp = Instance.new("BoxHandleAdornment")
            PartCrateEsp.Adornee = part
            PartCrateEsp.AlwaysOnTop = true
            PartCrateEsp.ZIndex = 0
            PartCrateEsp.Size = part.Size
            PartCrateEsp.Name = "PartCrate"
            PartCrateEsp.Transparency = 0.3
            PartCrateEsp.Color = BrickColor.new("Bright yellow")
            PartCrateEsp.Parent = workspace
            -- 
            espObjects[part] = PartCrateEsp
        end
    end
    --
    local function removeEsp(part)
        if espObjects[part] then
            espObjects[part]:Destroy()
            espObjects[part] = nil
        end
    end
--
    if toggleState then
        -- 
        local parts = workspace:GetDescendants()
        for _, part in ipairs(parts) do
            createEsp(part)
        end
        --
        local function onPartAdded(part)
            createEsp(part)
        end
--
        workspace.DescendantAdded:Connect(onPartAdded)
    else
        --
        for part, esp in pairs(espObjects) do
            removeEsp(part)
        end
        -- 
        workspace.DescendantAdded:Disconnect()
    end
end)
-- 
tab.newToggle("Stone ESP Toggle", "Toggle Stone ESP", true, function(toggleState)
    local espObjects = {}
--
    local function adornStoneOre(part)
        if part:IsA("MeshPart") and part.BrickColor == BrickColor.new("Flint") and part.Material == Enum.Material.Limestone then
            local parent = part.Parent
            if parent and parent:IsA("Model") and #parent:GetChildren() == 1 then
                local StoneEsp = Instance.new("BoxHandleAdornment")
                StoneEsp.Adornee = part
                StoneEsp.AlwaysOnTop = true
                StoneEsp.ZIndex = 0
                StoneEsp.Size = part.Size
                StoneEsp.Name = "Stone"
                StoneEsp.Transparency = 0.3
                StoneEsp.Color = BrickColor.new("Grey")
                StoneEsp.Parent = workspace
                espObjects[part] = StoneEsp
            end
        end
    end
--
    local function removeEsp(part)
        if espObjects[part] then
            espObjects[part]:Destroy()
            espObjects[part] = nil
        end
    end
--
    if toggleState then
        local parts = workspace:GetDescendants()
        for _, part in ipairs(parts) do
            adornStoneOre(part)
        end
--
        local function onPartAdded(part)
            adornStoneOre(part)
        end
--
        workspace.DescendantAdded:Connect(onPartAdded)
    else
        for part, esp in pairs(espObjects) do
            removeEsp(part)
        end
--
        workspace.DescendantAdded:Disconnect()
    end
end)
-- 
tab.newToggle("Iron ESP Toggle", "Toggle Iron ESP", true, function(toggleState)
    local espObjects = {}
--
    local function adornIronOre(part)
        if part:IsA("MeshPart") and part.BrickColor == BrickColor.new("Burlap") and part.Material == Enum.Material.Slate then
            local IronEsp = Instance.new("BoxHandleAdornment")
            IronEsp.Adornee = part
            IronEsp.AlwaysOnTop = true
            IronEsp.ZIndex = 0
            IronEsp.Size = part.Size
            IronEsp.Name = "Iron"
            IronEsp.Transparency = 0.3
            IronEsp.Color = BrickColor.new("Burlap")
            IronEsp.Parent = workspace
            espObjects[part] = IronEsp
        end
    end
--
    local function removeEsp(part)
        if espObjects[part] then
            espObjects[part]:Destroy()
            espObjects[part] = nil
        end
    end
--
    if toggleState then
        local parts = workspace:GetDescendants()
        for _, part in ipairs(parts) do
            adornIronOre(part)
        end
--
        local function onPartAdded(part)
            adornIronOre(part)
        end
--
        workspace.DescendantAdded:Connect(onPartAdded)
    else
        for part, esp in pairs(espObjects) do
            removeEsp(part)
        end
    end
end)
--
tab.newToggle("Nitrate ESP Toggle", "Toggle Nitrate ESP", true, function(toggleState)
    local espObjects = {}
--
    local function adornNitrateOre(part)
        if part:IsA("MeshPart") and part.BrickColor == BrickColor.new("Institutional white") and part.Material == Enum.Material.Slate then
            local NitrateEsp = Instance.new("BoxHandleAdornment")
            NitrateEsp.Adornee = part
            NitrateEsp.AlwaysOnTop = true
            NitrateEsp.ZIndex = 0
            NitrateEsp.Size = part.Size
            NitrateEsp.Name = "Nitrate"
            NitrateEsp.Transparency = 0.3
            NitrateEsp.Color = BrickColor.new("Institutional white")
            NitrateEsp.Parent = workspace
            espObjects[part] = NitrateEsp
        end
    end
--
    local function removeEsp(part)
        if espObjects[part] then
            espObjects[part]:Destroy()
            espObjects[part] = nil
        end
    end
--
    if toggleState then
        local parts = workspace:GetDescendants()
        for _, part in ipairs(parts) do
            adornNitrateOre(part)
        end
--
        local function onPartAdded(part)
            adornNitrateOre(part)
        end
--
        workspace.DescendantAdded:Connect(onPartAdded)
    else
        for part, esp in pairs(espObjects) do
            removeEsp(part)
        end
    end
end)
--
-- Hitsounds
local tab = DrRayLibrary.newTab("hitsounds", "ImageIdHere")
local SoundService = game:GetService("SoundService")
--
local sounds = {
    ["Defualt Headshot"] = "rbxassetid://9119561046",
    ["Defualt Body"] = "rbxassetid://9114487369",
    Neverlose = "rbxassetid://8726881116",
    Gamesense = "rbxassetid://4817809188",
    One = "rbxassetid://7380502345",
    Bell = "rbxassetid://6534947240",
    Rust = "rbxassetid://1255040462",
    TF2 = "rbxassetid://2868331684",
    Slime = "rbxassetid://6916371803",
    ["Among Us"] = "rbxassetid://5700183626",
    Minecraft = "rbxassetid://4018616850",
    ["CS:GO"] = "rbxassetid://6937353691",
    Saber = "rbxassetid://8415678813",
    Baimware = "rbxassetid://3124331820",
    Osu = "rbxassetid://7149255551",
    ["TF2 Critical"] = "rbxassetid://296102734",
    Bat = "rbxassetid://3333907347",
    ["Call of Duty"] = "rbxassetid://5952120301",
    Bubble = "rbxassetid://6534947588",
    Pick = "rbxassetid://1347140027",
    Pop = "rbxassetid://198598793",
    Bruh = "rbxassetid://4275842574",
    Bamboo = "rbxassetid://3769434519",
    Crowbar = "rbxassetid://546410481",
    Weeb = "rbxassetid://6442965016",
    Beep = "rbxassetid://8177256015",
    Bambi = "rbxassetid://8437203821",
    Stone = "rbxassetid://3581383408",
    ["Old Fatality"] = "rbxassetid://6607142036",
    Click = "rbxassetid://8053704437",
    Ding = "rbxassetid://7149516994",
    Snow = "rbxassetid://6455527632",
    Laser = "rbxassetid://7837461331",
    Mario = "rbxassetid://2815207981",
    Steve = "rbxassetid://4965083997",
}
local currentSound = nil
--
local function ApplySound(assetId)
    if not SoundService:FindFirstChild("PlayerHitHeadshot") then
        warn("SoundService.PlayerHitHeadshot not found!")
        return
    end
    local headshotSound = SoundService.PlayerHitHeadshot
    headshotSound.SoundId = assetId
    headshotSound.Volume = 5
    headshotSound.Pitch = 1
--
    local equalizer = headshotSound:FindFirstChildWhichIsA("EqualizerSoundEffect")
    if equalizer then
        equalizer.HighGain = -1.5
    end
end
--
local function ResetSound()
    if not SoundService:FindFirstChild("PlayerHitHeadshot") then
        return
    end
    local headshotSound = SoundService.PlayerHitHeadshot
    headshotSound.SoundId = "rbxassetid://9119561046" -- Default headshot sound
    headshotSound.Volume = 1
    headshotSound.Pitch = 1
--
    local equalizer = headshotSound:FindFirstChildWhichIsA("EqualizerSoundEffect")
    if equalizer then
        equalizer.HighGain = 0
    end
end
--
for name, assetId in pairs(sounds) do
    tab.newToggle(name, "Toggle " .. name .. " sound on/off", false, function(toggleState)
        if toggleState then
            currentSound = assetId
            ApplySound(assetId)
            print("Enabled sound:", name)
        else
            if currentSound == assetId then
                ResetSound()
                print("Reset sound back to default")
            end
        end
    end)
end
-- sky boxes
local tab = DrRayLibrary.newTab("sky box", "ImageIdHere")
local Lighting = game:GetService("Lighting")
--
local Sky = Instance.new("Sky")
Sky.Name = "CustomSky"
Sky.Parent = Lighting
--
local SkyBoxes = {
  ["Standard"] = {
    ["SkyboxBk"] = Sky.SkyboxBk, ["SkyboxDn"] = Sky.SkyboxDn,
    ["SkyboxFt"] = Sky.SkyboxFt, ["SkyboxLf"] = Sky.SkyboxLf,
    ["SkyboxRt"] = Sky.SkyboxRt, ["SkyboxUp"] = Sky.SkyboxUp
  },
  ["Among Us"] = {
    ["SkyboxBk"] = "rbxassetid://5752463190", ["SkyboxDn"] = "rbxassetid://5752463190",
    ["SkyboxFt"] = "rbxassetid://5752463190", ["SkyboxLf"] = "rbxassetid://5752463190",
    ["SkyboxRt"] = "rbxassetid://5752463190", ["SkyboxUp"] = "rbxassetid://5752463190"
  },
  ["Spongebob"] = {
    ["SkyboxBk"]="rbxassetid://277099484", ["SkyboxDn"]="rbxassetid://277099500",
    ["SkyboxFt"]="rbxassetid://277099554", ["SkyboxLf"]="rbxassetid://277099531",
    ["SkyboxRt"]="rbxassetid://277099589", ["SkyboxUp"]="rbxassetid://277101591"
  },
  ["Deep Space"] = {
    ["SkyboxBk"]="rbxassetid://159248188", ["SkyboxDn"]="rbxassetid://159248183",
    ["SkyboxFt"]="rbxassetid://159248187", ["SkyboxLf"]="rbxassetid://159248173",
    ["SkyboxRt"]="rbxassetid://159248192", ["SkyboxUp"]="rbxassetid://159248176"
  },
  ["Winter"] = {
    ["SkyboxBk"]="rbxassetid://510645155", ["SkyboxDn"]="rbxassetid://510645130",
    ["SkyboxFt"]="rbxassetid://510645179", ["SkyboxLf"]="rbxassetid://510645117",
    ["SkyboxRt"]="rbxassetid://510645146", ["SkyboxUp"]="rbxassetid://510645195"
  },
  ["Clouded Sky"] = {
    ["SkyboxBk"]="rbxassetid://252760981", ["SkyboxDn"]="rbxassetid://252763035",
    ["SkyboxFt"]="rbxassetid://252761439", ["SkyboxLf"]="rbxassetid://252760980",
    ["SkyboxRt"]="rbxassetid://252760986", ["SkyboxUp"]="rbxassetid://252762652"
  }
}
--
local currentSky = nil
--
local function setSkybox(data)
  for face, id in pairs(data) do
    Sky[face] = id
  end
end
--
for name, data in pairs(SkyBoxes) do
  tab.newToggle(name, "Enable " .. name .. " skybox", false, function(state)
    if state then
      setSkybox(data)
      currentSky = name
    elseif currentSky == name then
      for _, face in pairs({"SkyboxBk", "SkyboxDn", "SkyboxFt", "SkyboxLf", "SkyboxRt", "SkyboxUp"}) do
        Sky[face] = ""
      end
      currentSky = nil
    end
  end)
end
-- Print the name
for _, line in ipairs({
  "█████████████",
  "█▄─▄▄─█░▄▄░▄█",
  "██─▄█▀██▀▄█▀█",
  "▀▄▄▄▄▄▀▄▄▄▄▄▀",
  "█████████████████████████████████████████████████",
  "█▄─▄─▀██▀▄─██▄─▀█▄─▄█─▄▄▄▄█████▄─▄▄─█▄─▀─▄█▄─▄▄─█",
  "██─▄─▀██─▀─███─█▄▀─██▄▄▄▄─█░░███─▄█▀██▀─▀███─▄█▀█",
  "▀▄▄▄▄▀▀▄▄▀▄▄▀▄▄▄▀▀▄▄▀▄▄▄▄▄▀▄▄▀▀▄▄▄▄▄▀▄▄█▄▄▀▄▄▄▄▄▀"
}) do
    warn(line)
end
local TextLabel = Drawing.new("Text")
TextLabel.Text = "Ez bans.exe - free - v2"
TextLabel.Size = 24
TextLabel.Center = true
TextLabel.Outline = true
TextLabel.Visible = true

local viewportSize = game:GetService("Workspace").CurrentCamera.ViewportSize
TextLabel.Position = Vector2.new(viewportSize.X / 2, 15)

local RunService = game:GetService("RunService")
local hue = 0

RunService.RenderStepped:Connect(function()
    hue = (hue + 0.01) % 1
    local color = Color3.fromHSV(hue, 1, 1)
    TextLabel.Color = color
    
    local newViewportSize = game:GetService("Workspace").CurrentCamera.ViewportSize
    TextLabel.Position = Vector2.new(newViewportSize.X / 2, 15)
end)
